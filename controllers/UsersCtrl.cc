/**
 *
 *  UsersCtrl.cc
 *  This file is generated by drogon_ctl
 *
 */

#include "UsersCtrl.h"
#include <string>


bool validateJsonForLogin(const Json::Value &pJson, std::string &err)
{
    bool hasId = false;
    if(pJson.isMember("name"))
    {
        hasId = true;
        if(!UsersExt::validJsonOfField(1, "name", pJson["name"], err, false))
            return false;
    }
    if(pJson.isMember("email"))
    {
        if (hasId) {
            err = "Should contain either either name, either email columns";
            return false;
        }
        hasId = true;
        if(!UsersExt::validJsonOfField(2, "email", pJson["email"], err, false))
            return false;
    }
    if (!hasId) {
        err = "One of the columns (name, email) should be set";
        return false;
    }
    return UsersExt::validateJsonForPassword(pJson, err);
}


void UsersCtrl::login(const HttpRequestPtr &req,
           std::function<void(const HttpResponsePtr &)> &&callback)

{
    auto jsonPtr=req->jsonObject();
    if(!jsonPtr)
    {
        Json::Value ret;
        ret["error"]="No json object is found in the request";
        auto resp= HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k400BadRequest);
        callback(resp);
        return;
    }

    auto pJson = *jsonPtr;
    std::string err;
    try
    {
        if(!validateJsonForLogin(pJson, err))
        {
            Json::Value ret;
            ret["error"] = err;
            auto resp= HttpResponse::newHttpJsonResponse(ret);
            resp->setStatusCode(k400BadRequest);
            callback(resp);
            return;
        }

    }
    catch(const Json::Exception &e)
    {
        LOG_ERROR << e.what();
        Json::Value ret;
        ret["error"]="Field type error";
        auto resp= HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k400BadRequest);
        callback(resp);
        return;
    }

    std::string name = pJson["name"].asString();
    std::string email = pJson["email"].asString();
    std::string password = pJson["password"].asString();
    auto criteria = name.empty()
                    ? drogon::orm::Criteria(UsersExt::Cols::_email, CompareOperator::EQ, email)
                    : drogon::orm::Criteria(UsersExt::Cols::_name, CompareOperator::EQ, name);
    auto dbClientPtr = getDbClient();
    auto callbackPtr =
            std::make_shared<std::function<void(const HttpResponsePtr &)>>(
                    std::move(callback));
    drogon::orm::Mapper<UsersExt> mapper(dbClientPtr);

    mapper.findOne(
            criteria,
            [callbackPtr, password](const UsersExt& object)
            {
                if (!object.checkPassword(password)) {
                    auto resp = HttpResponse::newHttpResponse();
                    resp->setStatusCode(k401Unauthorized);
                    (*callbackPtr)(resp);
                    return;
                }
                Json::Value ret;
                ret["token"] = UsersExt::generateToken(object.getValueOfId());
                auto resp = HttpResponse::newHttpJsonResponse(ret);
                (*callbackPtr)(resp);
            },
            [callbackPtr](const DrogonDbException &e) {
                const auto *s=dynamic_cast<const drogon::orm::UnexpectedRows *>(&e.base());
                if(s)
                {
                    auto resp = HttpResponse::newHttpResponse();
                    resp->setStatusCode(k404NotFound);
                    (*callbackPtr)(resp);
                    return;
                }
                LOG_ERROR << e.base().what();
                Json::Value ret;
                ret["error"] = "database error";
                auto resp = HttpResponse::newHttpJsonResponse(ret);
                resp->setStatusCode(k500InternalServerError);
                (*callbackPtr)(resp);
            });
}


void UsersCtrl::getOne(const HttpRequestPtr &req,
                       std::function<void(const HttpResponsePtr &)> &&callback,
                       Users::PrimaryKeyType &&id)
{
    UsersCtrlBase<UsersExt>::getOne(req, std::move(callback), std::move(id));
}


void UsersCtrl::updateOne(const HttpRequestPtr &req,
                          std::function<void(const HttpResponsePtr &)> &&callback,
                          Users::PrimaryKeyType &&id)
{
    UsersCtrlBase<UsersExt>::updateOne(req, std::move(callback), std::move(id));
}


void UsersCtrl::deleteOne(const HttpRequestPtr &req,
                          std::function<void(const HttpResponsePtr &)> &&callback,
                          Users::PrimaryKeyType &&id)
{
    UsersCtrlBase<UsersExt>::deleteOne(req, std::move(callback), std::move(id));
}

void UsersCtrl::get(const HttpRequestPtr &req,
                    std::function<void(const HttpResponsePtr &)> &&callback)
{
    UsersCtrlBase<UsersExt>::get(req, std::move(callback));
}

void UsersCtrl::create(const HttpRequestPtr &req,
                       std::function<void(const HttpResponsePtr &)> &&callback)
{
    UsersCtrlBase<UsersExt>::create(req, std::move(callback));
}
